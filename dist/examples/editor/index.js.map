{"version":3,"file":"index.js","sources":["../../../spui/utils.ts","../../../spui/stream.ts","../../../spui/dom.ts","../../../examples/editor/index.ts"],"sourcesContent":["export interface StringKeyMap<T> {\r\n    [key: string]: T;\r\n}\r\nexport type Functor0P = () => any;\r\nexport type Functor1P = (value: any) => any;\r\n\r\nexport function isFunction(obj): obj is Function {\r\n    return typeof obj === 'function';\r\n}\r\n\r\nexport function isNode(obj): obj is Node {\r\n    return obj.nodeType;\r\n}\r\n\r\nexport function isObject(obj): obj is Object {\r\n    return typeof obj === 'object';\r\n}\r\n\r\nexport function isString(obj): obj is string {\r\n    return typeof obj === 'string'; \r\n}\r\n\r\nexport function expandValue(value): any {\r\n    return isFunction(value) ? value() : value; \r\n}\r\n\r\nexport function remove(array: Array<any>, value) {\r\n    const i = array.indexOf(value);\r\n    if (i !== -1) {\r\n        array.splice(i, 1);\r\n    }\r\n    return array;\r\n}","import { isFunction, remove, Functor0P, Functor1P} from './utils';\r\nexport interface GetterSetter {\r\n    (value?): any;\r\n}\r\nexport interface Stream extends GetterSetter {\r\n    _backingValue: any;\r\n    _listeners?: Array<Functor1P>;\r\n    _transform?: Functor1P;\r\n}\r\nexport interface Computation {\r\n    computedStream: Stream;\r\n    dependencies: Stream[];\r\n}\r\n\r\nlet runningComputations: Array<Computation> = [];\r\n\r\nfunction setValue(stream, value) {\r\n    stream._backingValue = stream._transform ? stream._transform(value) : value;\r\n    if (stream._listeners.length) {\r\n        const dependencies = stream._listeners.slice();\r\n        for (let i = 0; i < dependencies.length; ++i) {\r\n            dependencies[i](stream._backingValue);\r\n        }\r\n    }\r\n}\r\n\r\nexport function valueStream(initialValue?, transform?: Functor1P) : Stream {\r\n    let stream = function (value?) {\r\n        if (arguments.length) {\r\n            setValue(stream, value);\r\n        } else {\r\n            // Check to create a new computation dependency:\r\n            if (runningComputations.length) {\r\n                const computation = runningComputations[runningComputations.length - 1];\r\n                addListener(stream, computation.computedStream);\r\n                computation.dependencies.push(stream);\r\n            }\r\n        }\r\n        \r\n        return stream._backingValue;\r\n    } as Stream;\r\n\r\n    stream._listeners = [];\r\n    if (transform) {\r\n        stream._transform = transform;\r\n    }\r\n    if (initialValue !== undefined) {\r\n        setValue(stream, initialValue);\r\n    }\r\n\r\n    return stream;\r\n}\r\n\r\nexport function addListener(stream: Stream, listener: Functor1P) : Functor0P {\r\n    if (stream._listeners.indexOf(listener) === -1) {\r\n        stream._listeners.push(listener);\r\n    }\r\n    return () => removeListener(stream, listener);\r\n}\r\n\r\nexport function removeListener(valueStream: Stream, listener: Functor1P) : void {\r\n    remove(valueStream._listeners, listener);\r\n}\r\n\r\nexport function addTransform(valueStream: Stream, transform: Functor1P) {\r\n    if (valueStream._transform) {\r\n        const firstTransform = valueStream._transform;\r\n        valueStream._transform = value => transform(firstTransform(value));\r\n    } else {\r\n        valueStream._transform = transform;\r\n    }\r\n}\r\n\r\nexport function map(vs: Stream, transform: Functor1P) : Stream {\r\n    const computedStream = valueStream(vs(), transform);\r\n    addListener(vs, computedStream);\r\n    return computedStream;\r\n}\r\n\r\nfunction createComputation() : Computation {\r\n    return {\r\n        computedStream: valueStream(),\r\n        dependencies: []\r\n    };\r\n}\r\n\r\nexport function compute(functor: Functor0P) : Computation {\r\n    const computation = createComputation();\r\n    computation.computedStream(_compute());\r\n    addTransform(computation.computedStream, _compute);\r\n    return computation;\r\n\r\n    function _compute() {\r\n        runningComputations.push(computation);\r\n        let result, error;\r\n        try {\r\n            result = functor();\r\n        }\r\n        catch (e) {\r\n            error = e;\r\n        }\r\n        runningComputations.pop();\r\n        if (error) throw error;\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function computeStream(functor: Functor0P): Stream {\r\n    return compute(functor).computedStream;\r\n}\r\n\r\nexport function eventStream(source: EventTarget | string, name: string, useCapture?) {\r\n    const eventStream = valueStream();\r\n    const element = source instanceof EventTarget ? source : document.querySelector(source);\r\n    element.addEventListener(name, eventStream, !!useCapture);\r\n    return eventStream;\r\n}","import { isNode, isFunction, isString, isObject, expandValue, StringKeyMap, Functor0P, Functor1P} from './utils';\r\nimport * as s from './stream';\r\nimport {ObservableArray} from './observable-array';\r\n\r\nexport type Attrs = StringKeyMap<any>;\r\nexport type ElementGenerator = () => HTMLElement;\r\nexport type StringGenerator = () => string;\r\nexport type Child = string | HTMLElement | ElementGenerator | StringGenerator;\r\nexport type Children = Array<Child> | Child;\r\nexport type ModelElementCreator = (listRootElement: HTMLElement, model: any, indeX: number) => HTMLElement;\r\n\r\nexport function h(tagName: string, attrs?: Attrs, children?: Children) {\r\n    const element = document.createElement(tagName);\r\n    if (attrs) {\r\n        setAttrs(element, attrs);\r\n    }\r\n\r\n    if (children) {\r\n        setChildren(element, children);\r\n    }\r\n    return element;\r\n}\r\n\r\nfunction setAttrs(element: HTMLElement, attr: Attrs) {\r\n    // For each attr, setup a computation. When that computation is triggered, we patch this argument:\r\n    for (const attrName in attr) {\r\n        const attrValue = attr[attrName];\r\n        // Event registration handling.\r\n        if (attrName.startsWith('on')) {\r\n            const eventName = attrName.slice(2);\r\n            element.addEventListener(eventName, attrValue);\r\n            continue;\r\n        }\r\n\r\n        // If attrValue is an object (for classes and styles)\r\n        // or if attrValue is a function: setup a computation\r\n        if (isFunction(attrValue) || isObject(attrValue)) {\r\n            // For all attributes resulting from a computation setup auto update:\r\n            const computation = s.compute(() => {\r\n                setAttr(element, attrName, attrValue);\r\n            });\r\n\r\n            // Check if the attrValue function has actually registered a dependency:\r\n            if (computation.dependencies.length) {\r\n                s.addTransform(computation.computedStream, () => {\r\n                    setAttr(element, attrName, attrValue);\r\n                });\r\n            }\r\n            continue;\r\n        }\r\n        // Handle static attributes:\r\n        setAttr(element, attrName, attrValue);\r\n    }\r\n}\r\n\r\nfunction setAttr(element: HTMLElement, attr: string, value: any) {\r\n    value = expandValue(value);\r\n    switch(attr) {\r\n        case 'class':\r\n        case 'className':\r\n            setClass(element, value);\r\n        break\r\n        case 'style':\r\n            setStyle(element, value);\r\n        break;\r\n        default: \r\n            if (attr in element) {\r\n                element[attr] = value;\r\n            } else if (value === false) {\r\n                element.removeAttribute(attr);\r\n            } else if (value === true) {\r\n                // If value is a boolean, set it to \"\" to only enable it in DOM.\r\n                element.setAttribute(attr, \"\");\r\n            } else {\r\n                element.setAttribute(attr, value);\r\n            }\r\n    }\r\n}\r\n\r\nfunction setClass(element: HTMLElement, className: string | Attrs) {\r\n    if (isString(className)) {\r\n        element.className = className;\r\n    } else {\r\n        let newClass = '';\r\n        for (const key in className) {\r\n            let value = className[key];\r\n            value = expandValue(value);\r\n            if (value) {\r\n                newClass += (newClass == '' ? '' : ' ' ) + key;\r\n            }\r\n        }\r\n        element.className = newClass;\r\n    }\r\n}\r\n\r\nfunction setStyle(element: HTMLElement, style: Attrs | string, value?) {\r\n    if (isString(style)) {\r\n        element.setAttribute('style', style);\r\n    } else {\r\n        for (const key in style) {\r\n            const styleValue = expandValue(style[key]);\r\n            element.style[key] = styleValue;\r\n        }\r\n    }\r\n}\r\n\r\nfunction setChildren(element: HTMLElement, children: Children) {\r\n    if (Array.isArray(children)) {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            appendChild(element, children[i]);\r\n        }\r\n    } else {\r\n        appendChild(element, children);\r\n    }\r\n}\r\n\r\nfunction appendChild(element: HTMLElement, child: Child) {\r\n    if (!child) return;\r\n    if (isFunction(child)) {\r\n        let resolvedChild: HTMLElement | string;\r\n        const computation = s.compute(() => {\r\n            resolvedChild = child();\r\n        });\r\n\r\n        let childNode = isNode(resolvedChild) ? resolvedChild : document.createTextNode(resolvedChild);\r\n        element.appendChild(childNode);\r\n\r\n        if (computation.dependencies.length) {\r\n            // Auto update in case children is a stream\r\n            s.addTransform(computation.computedStream, () => {\r\n                const oldChildNode = childNode;\r\n                childNode = isNode(resolvedChild) ? resolvedChild : document.createTextNode(resolvedChild);\r\n                element.replaceChild(childNode, oldChildNode);\r\n            });\r\n        }\r\n    } else if (isNode(child)) {\r\n        element.appendChild(child);\r\n    } else {\r\n        element.appendChild(document.createTextNode(child));\r\n    }\r\n}\r\n\r\nexport class ElementListMapper {\r\n    modelsObs: ObservableArray<any>;\r\n    listRootElement: HTMLElement;\r\n    elementCreator: ModelElementCreator;\r\n    key: string;\r\n    modelToElement: Map<any, HTMLElement>;\r\n    constructor(listRootElement: HTMLElement, modelsObs: ObservableArray<any>, elementCreator: ModelElementCreator, key?: string) {\r\n        this.listRootElement = listRootElement;\r\n        this.modelsObs = modelsObs;\r\n        this.elementCreator = elementCreator;\r\n        // TODO: What to do with key?\r\n        this.key = key;\r\n        this.modelToElement = new Map<any, HTMLElement>();\r\n        modelsObs.addListener(this.onModelChange.bind(this));\r\n\r\n        if (this.modelsObs.length) {\r\n            const nodes = this.createElements(this.modelsObs.array, 0);\r\n            this.listRootElement.appendChild(nodes);\r\n        }\r\n    }\r\n\r\n    onModelChange (op: string, args: any[]) {\r\n        switch(op) {\r\n            case 'pop':\r\n                this.listRootElement.removeChild(this.listRootElement.lastChild);\r\n                break;\r\n            case 'push': {\r\n                const nodes = this.createElements(args, this.modelsObs.length - args.length);\r\n                this.listRootElement.appendChild(nodes);\r\n                break;\r\n            }\r\n            case 'reverse': {\r\n                const frag = new DocumentFragment();\r\n                while (this.listRootElement.lastChild) {\r\n                    frag.appendChild(this.listRootElement.removeChild(this.listRootElement.lastChild));\r\n                }\r\n                this.listRootElement.appendChild(frag);\r\n                break;\r\n            };\r\n            case 'splice':\r\n                const childNodes = this.listRootElement.childNodes;\r\n                const spliceStart = args[0] < 0 ? childNodes.length + args[0] : args[0];\r\n                const deleteCount = args.length > 1 ? args[1] : childNodes.length - spliceStart;\r\n                const deleteStop = spliceStart + deleteCount;\r\n                // TODO: have a more flexible splice that doesn't ALWAYS create a toRemove array\r\n                // or keep the list of ordered nodes on the side?\r\n                const toRemove = [];\r\n                for (let i = spliceStart; i < deleteStop; i++) {\r\n                    toRemove.push(childNodes[i]);\r\n                }\r\n                for (let i = 0; i < toRemove.length; ++i) {\r\n                    this.listRootElement.removeChild(toRemove[i]);\r\n                }\r\n\r\n                if (args.length > 2) {\r\n                    const nodes = this.createElements(args.slice(2), spliceStart);\r\n                    this.listRootElement.insertBefore(nodes, childNodes[spliceStart]);\r\n                }\r\n                break;\r\n            case 'shift':\r\n                this.listRootElement.removeChild(this.listRootElement.firstChild);\r\n                break;\r\n            case 'sort': {\r\n                const frag = new DocumentFragment();\r\n                for (let i = 0; i < this.modelsObs.length; ++i) {\r\n                    const node = this.modelToElement.get(this.modelsObs.array[i]);\r\n                    this.listRootElement.removeChild(node);\r\n                    frag.appendChild(node);\r\n                }\r\n                this.listRootElement.appendChild(frag);\r\n                break;\r\n            }\r\n            case 'unshift': {\r\n                const nodes = this.createElements(args, 0);\r\n                this.listRootElement.insertBefore(nodes, this.listRootElement.firstChild);\r\n                break;\r\n            }\r\n            case 'changes': {\r\n                const changes = args;\r\n                for (let i = 0; i < changes.length; ++i) {\r\n                    this.onModelChange(changes[i][0], changes[i][1]);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    createElements(models: Array<any>, startIndex: number) : DocumentFragment | HTMLElement {\r\n        if (models.length > 1) {\r\n            const frag = new DocumentFragment();\r\n            for (let i = 0; i < models.length; ++i) {\r\n                const childNode = this.createElement(models[i], startIndex++);\r\n                frag.appendChild(childNode);\r\n            }\r\n            return frag;\r\n        }\r\n\r\n        return this.createElement(models[0], startIndex);\r\n    }\r\n\r\n    createElement(model, index: number) : HTMLElement {\r\n        const childNode = this.elementCreator(this.listRootElement, model, index);\r\n        this.modelToElement.set(model, childNode);\r\n        return childNode;\r\n    }\r\n}\r\n\r\nexport function elementList(tagName: string, attrs: Attrs, models: ObservableArray<any>, nodeCreator: ModelElementCreator, key?: string) {\r\n    const listRootElement = h(tagName, attrs);\r\n    (parent as any)._elementList = new ElementListMapper(listRootElement, models, nodeCreator, key);\r\n    return  listRootElement;\r\n}\r\n\r\nexport function isElementList(nodeListElement: HTMLElement) : boolean {\r\n    return !!((parent as any)._elementList);\r\n}\r\n\r\nexport function getElementList(nodeListElement: HTMLElement): ElementListMapper {\r\n    return (parent as any)._elementList;\r\n}\r\n\r\nexport function targetAttr(eventAttrName: string, functor: s.Stream | Functor1P) {\r\n    return function (event) {\r\n        return functor(event.target[eventAttrName]);\r\n    }\r\n}","import * as sp from '../../spui/index';\r\nimport * as utils from '../../spui/utils';\r\n\r\nconst h = sp.h;\r\nconst marked = (window as any).marked;\r\n\r\nlet htmlTextElement = h('div');\r\n\r\nconst markdownText = sp.valueStream(`# Markdown Editor\\n\\nType on the left panel and see the result on the right panel`);\r\nconst htmlText = sp.map(markdownText, md => {\r\n    htmlTextElement.innerHTML = marked(md);\r\n});\r\n\r\nconst editor = h('div', {id: 'editor'}, [\r\n    h('textarea', { class: 'input', value: markdownText, oninput: sp.targetAttr('value', markdownText)}),\r\n    h('div', { class: 'preview' }, htmlTextElement),\r\n]);\r\n\r\ndocument.body.appendChild(editor);"],"names":["s.compute","s.addTransform","sp.h","sp.valueStream","sp.map","sp.targetAttr"],"mappings":"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"}