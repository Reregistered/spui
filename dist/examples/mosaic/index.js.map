{"version":3,"file":"index.js","sources":["../../../spui/utils.ts","../../../spui/stream.ts","../../../spui/dom.ts","../../../spui/observable-array.ts","../../../examples/mosaic/index.ts"],"sourcesContent":["export interface StringKeyMap<T> {\r\n    [key: string]: T;\r\n}\r\nexport type Functor0P = () => any;\r\nexport type Functor1P = (value: any) => any;\r\n\r\nexport function isFunction(obj): obj is Function {\r\n    return typeof obj === 'function';\r\n}\r\n\r\nexport function isNode(obj): obj is Node {\r\n    return obj.nodeType;\r\n}\r\n\r\nexport function isObject(obj): obj is Object {\r\n    return typeof obj === 'object';\r\n}\r\n\r\nexport function isString(obj): obj is string {\r\n    return typeof obj === 'string'; \r\n}\r\n\r\nexport function expandValue(value): any {\r\n    return isFunction(value) ? value() : value; \r\n}\r\n\r\nexport function remove(array: Array<any>, value) {\r\n    const i = array.indexOf(value);\r\n    if (i !== -1) {\r\n        array.splice(i, 1);\r\n    }\r\n    return array;\r\n}","import { isFunction, remove, Functor0P, Functor1P} from './utils';\r\nexport interface GetterSetter {\r\n    (value?): any;\r\n}\r\nexport interface Stream extends GetterSetter {\r\n    _backingValue: any;\r\n    _listeners?: Array<Functor1P>;\r\n    _transform?: Functor1P;\r\n}\r\nexport interface Computation {\r\n    computedStream: Stream;\r\n    dependencies: Stream[];\r\n}\r\n\r\nlet runningComputations: Array<Computation> = [];\r\n\r\nfunction setValue(stream, value) {\r\n    stream._backingValue = stream._transform ? stream._transform(value) : value;\r\n    if (stream._listeners.length) {\r\n        const dependencies = stream._listeners.slice();\r\n        for (let i = 0; i < dependencies.length; ++i) {\r\n            dependencies[i](stream._backingValue);\r\n        }\r\n    }\r\n}\r\n\r\nexport function valueStream(initialValue?, transform?: Functor1P) : Stream {\r\n    let stream = function (value?) {\r\n        if (arguments.length) {\r\n            setValue(stream, value);\r\n        } else {\r\n            // Check to create a new computation dependency:\r\n            if (runningComputations.length) {\r\n                const computation = runningComputations[runningComputations.length - 1];\r\n                addListener(stream, computation.computedStream);\r\n                computation.dependencies.push(stream);\r\n            }\r\n        }\r\n        \r\n        return stream._backingValue;\r\n    } as Stream;\r\n\r\n    stream._listeners = [];\r\n    if (transform) {\r\n        stream._transform = transform;\r\n    }\r\n    if (initialValue !== undefined) {\r\n        setValue(stream, initialValue);\r\n    }\r\n\r\n    return stream;\r\n}\r\n\r\nexport function addListener(stream: Stream, listener: Functor1P) : Functor0P {\r\n    if (stream._listeners.indexOf(listener) === -1) {\r\n        stream._listeners.push(listener);\r\n    }\r\n    return () => removeListener(stream, listener);\r\n}\r\n\r\nexport function removeListener(valueStream: Stream, listener: Functor1P) : void {\r\n    remove(valueStream._listeners, listener);\r\n}\r\n\r\nexport function addTransform(valueStream: Stream, transform: Functor1P) {\r\n    if (valueStream._transform) {\r\n        const firstTransform = valueStream._transform;\r\n        valueStream._transform = value => transform(firstTransform(value));\r\n    } else {\r\n        valueStream._transform = transform;\r\n    }\r\n}\r\n\r\nexport function map(vs: Stream, transform: Functor1P) : Stream {\r\n    const computedStream = valueStream(vs(), transform);\r\n    addListener(vs, computedStream);\r\n    return computedStream;\r\n}\r\n\r\nfunction createComputation() : Computation {\r\n    return {\r\n        computedStream: valueStream(),\r\n        dependencies: []\r\n    };\r\n}\r\n\r\nexport function compute(functor: Functor0P) : Computation {\r\n    const computation = createComputation();\r\n    computation.computedStream(_compute());\r\n    addTransform(computation.computedStream, _compute);\r\n    return computation;\r\n\r\n    function _compute() {\r\n        runningComputations.push(computation);\r\n        let result, error;\r\n        try {\r\n            result = functor();\r\n        }\r\n        catch (e) {\r\n            error = e;\r\n        }\r\n        runningComputations.pop();\r\n        if (error) throw error;\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function computeStream(functor: Functor0P): Stream {\r\n    return compute(functor).computedStream;\r\n}\r\n\r\nexport function eventStream(source: EventTarget | string, name: string, useCapture?) {\r\n    const eventStream = valueStream();\r\n    const element = source instanceof EventTarget ? source : document.querySelector(source);\r\n    element.addEventListener(name, eventStream, !!useCapture);\r\n    return eventStream;\r\n}","import { isNode, isFunction, isString, isObject, expandValue, StringKeyMap, Functor0P, Functor1P} from './utils';\r\nimport * as s from './stream';\r\nimport {ObservableArray} from './observable-array';\r\n\r\nexport type Attrs = StringKeyMap<any>;\r\nexport type ElementGenerator = () => HTMLElement;\r\nexport type StringGenerator = () => string;\r\nexport type Child = string | HTMLElement | ElementGenerator | StringGenerator;\r\nexport type Children = Array<Child> | Child;\r\nexport type ModelElementCreator = (listRootElement: HTMLElement, model: any, indeX: number) => HTMLElement;\r\n\r\nexport function h(tagName: string, attrs?: Attrs, children?: Children) {\r\n    const element = document.createElement(tagName);\r\n    if (attrs) {\r\n        setAttrs(element, attrs);\r\n    }\r\n\r\n    if (children) {\r\n        setChildren(element, children);\r\n    }\r\n    return element;\r\n}\r\n\r\nfunction setAttrs(element: HTMLElement, attr: Attrs) {\r\n    // For each attr, setup a computation. When that computation is triggered, we patch this argument:\r\n    for (const attrName in attr) {\r\n        const attrValue = attr[attrName];\r\n        // Event registration handling.\r\n        if (attrName.startsWith('on')) {\r\n            const eventName = attrName.slice(2);\r\n            element.addEventListener(eventName, attrValue);\r\n            continue;\r\n        }\r\n\r\n        // If attrValue is an object (for classes and styles)\r\n        // or if attrValue is a function: setup a computation\r\n        if (isFunction(attrValue) || isObject(attrValue)) {\r\n            // For all attributes resulting from a computation setup auto update:\r\n            const computation = s.compute(() => {\r\n                setAttr(element, attrName, attrValue);\r\n            });\r\n\r\n            // Check if the attrValue function has actually registered a dependency:\r\n            if (computation.dependencies.length) {\r\n                s.addTransform(computation.computedStream, () => {\r\n                    setAttr(element, attrName, attrValue);\r\n                });\r\n            }\r\n            continue;\r\n        }\r\n        // Handle static attributes:\r\n        setAttr(element, attrName, attrValue);\r\n    }\r\n}\r\n\r\nfunction setAttr(element: HTMLElement, attr: string, value: any) {\r\n    value = expandValue(value);\r\n    switch(attr) {\r\n        case 'class':\r\n        case 'className':\r\n            setClass(element, value);\r\n        break\r\n        case 'style':\r\n            setStyle(element, value);\r\n        break;\r\n        default: \r\n            if (attr in element) {\r\n                element[attr] = value;\r\n            } else if (value === false) {\r\n                element.removeAttribute(attr);\r\n            } else if (value === true) {\r\n                // If value is a boolean, set it to \"\" to only enable it in DOM.\r\n                element.setAttribute(attr, \"\");\r\n            } else {\r\n                element.setAttribute(attr, value);\r\n            }\r\n    }\r\n}\r\n\r\nfunction setClass(element: HTMLElement, className: string | Attrs) {\r\n    if (isString(className)) {\r\n        element.className = className;\r\n    } else {\r\n        let newClass = '';\r\n        for (const key in className) {\r\n            let value = className[key];\r\n            value = expandValue(value);\r\n            if (value) {\r\n                newClass += (newClass == '' ? '' : ' ' ) + key;\r\n            }\r\n        }\r\n        element.className = newClass;\r\n    }\r\n}\r\n\r\nfunction setStyle(element: HTMLElement, style: Attrs | string, value?) {\r\n    if (isString(style)) {\r\n        element.setAttribute('style', style);\r\n    } else {\r\n        for (const key in style) {\r\n            const styleValue = expandValue(style[key]);\r\n            element.style[key] = styleValue;\r\n        }\r\n    }\r\n}\r\n\r\nfunction setChildren(element: HTMLElement, children: Children) {\r\n    if (Array.isArray(children)) {\r\n        for (let i = 0; i < children.length; ++i) {\r\n            appendChild(element, children[i]);\r\n        }\r\n    } else {\r\n        appendChild(element, children);\r\n    }\r\n}\r\n\r\nfunction appendChild(element: HTMLElement, child: Child) {\r\n    if (!child) return;\r\n    if (isFunction(child)) {\r\n        let resolvedChild: HTMLElement | string;\r\n        const computation = s.compute(() => {\r\n            resolvedChild = child();\r\n        });\r\n\r\n        let childNode = isNode(resolvedChild) ? resolvedChild : document.createTextNode(resolvedChild);\r\n        element.appendChild(childNode);\r\n\r\n        if (computation.dependencies.length) {\r\n            // Auto update in case children is a stream\r\n            s.addTransform(computation.computedStream, () => {\r\n                const oldChildNode = childNode;\r\n                childNode = isNode(resolvedChild) ? resolvedChild : document.createTextNode(resolvedChild);\r\n                element.replaceChild(childNode, oldChildNode);\r\n            });\r\n        }\r\n    } else if (isNode(child)) {\r\n        element.appendChild(child);\r\n    } else {\r\n        element.appendChild(document.createTextNode(child));\r\n    }\r\n}\r\n\r\nexport class ElementListMapper {\r\n    modelsObs: ObservableArray<any>;\r\n    listRootElement: HTMLElement;\r\n    elementCreator: ModelElementCreator;\r\n    key: string;\r\n    modelToElement: Map<any, HTMLElement>;\r\n    constructor(listRootElement: HTMLElement, modelsObs: ObservableArray<any>, elementCreator: ModelElementCreator, key?: string) {\r\n        this.listRootElement = listRootElement;\r\n        this.modelsObs = modelsObs;\r\n        this.elementCreator = elementCreator;\r\n        // TODO: What to do with key?\r\n        this.key = key;\r\n        this.modelToElement = new Map<any, HTMLElement>();\r\n        modelsObs.addListener(this.onModelChange.bind(this));\r\n\r\n        if (this.modelsObs.length) {\r\n            const nodes = this.createElements(this.modelsObs.array, 0);\r\n            this.listRootElement.appendChild(nodes);\r\n        }\r\n    }\r\n\r\n    onModelChange (op: string, args: any[]) {\r\n        switch(op) {\r\n            case 'pop':\r\n                this.listRootElement.removeChild(this.listRootElement.lastChild);\r\n                break;\r\n            case 'push': {\r\n                const nodes = this.createElements(args, this.modelsObs.length - args.length);\r\n                this.listRootElement.appendChild(nodes);\r\n                break;\r\n            }\r\n            case 'reverse': {\r\n                const frag = new DocumentFragment();\r\n                while (this.listRootElement.lastChild) {\r\n                    frag.appendChild(this.listRootElement.removeChild(this.listRootElement.lastChild));\r\n                }\r\n                this.listRootElement.appendChild(frag);\r\n                break;\r\n            };\r\n            case 'splice':\r\n                const childNodes = this.listRootElement.childNodes;\r\n                const spliceStart = args[0] < 0 ? childNodes.length + args[0] : args[0];\r\n                const deleteCount = args.length > 1 ? args[1] : childNodes.length - spliceStart;\r\n                const deleteStop = spliceStart + deleteCount;\r\n                // TODO: have a more flexible splice that doesn't ALWAYS create a toRemove array\r\n                // or keep the list of ordered nodes on the side?\r\n                const toRemove = [];\r\n                for (let i = spliceStart; i < deleteStop; i++) {\r\n                    toRemove.push(childNodes[i]);\r\n                }\r\n                for (let i = 0; i < toRemove.length; ++i) {\r\n                    this.listRootElement.removeChild(toRemove[i]);\r\n                }\r\n\r\n                if (args.length > 2) {\r\n                    const nodes = this.createElements(args.slice(2), spliceStart);\r\n                    this.listRootElement.insertBefore(nodes, childNodes[spliceStart]);\r\n                }\r\n                break;\r\n            case 'shift':\r\n                this.listRootElement.removeChild(this.listRootElement.firstChild);\r\n                break;\r\n            case 'sort': {\r\n                const frag = new DocumentFragment();\r\n                for (let i = 0; i < this.modelsObs.length; ++i) {\r\n                    const node = this.modelToElement.get(this.modelsObs.array[i]);\r\n                    this.listRootElement.removeChild(node);\r\n                    frag.appendChild(node);\r\n                }\r\n                this.listRootElement.appendChild(frag);\r\n                break;\r\n            }\r\n            case 'unshift': {\r\n                const nodes = this.createElements(args, 0);\r\n                this.listRootElement.insertBefore(nodes, this.listRootElement.firstChild);\r\n                break;\r\n            }\r\n            case 'changes': {\r\n                const changes = args;\r\n                for (let i = 0; i < changes.length; ++i) {\r\n                    this.onModelChange(changes[i][0], changes[i][1]);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    createElements(models: Array<any>, startIndex: number) : DocumentFragment | HTMLElement {\r\n        if (models.length > 1) {\r\n            const frag = new DocumentFragment();\r\n            for (let i = 0; i < models.length; ++i) {\r\n                const childNode = this.createElement(models[i], startIndex++);\r\n                frag.appendChild(childNode);\r\n            }\r\n            return frag;\r\n        }\r\n\r\n        return this.createElement(models[0], startIndex);\r\n    }\r\n\r\n    createElement(model, index: number) : HTMLElement {\r\n        const childNode = this.elementCreator(this.listRootElement, model, index);\r\n        this.modelToElement.set(model, childNode);\r\n        return childNode;\r\n    }\r\n}\r\n\r\nexport function elementList(tagName: string, attrs: Attrs, models: ObservableArray<any>, nodeCreator: ModelElementCreator, key?: string) {\r\n    const listRootElement = h(tagName, attrs);\r\n    (parent as any)._elementList = new ElementListMapper(listRootElement, models, nodeCreator, key);\r\n    return  listRootElement;\r\n}\r\n\r\nexport function isElementList(nodeListElement: HTMLElement) : boolean {\r\n    return !!((parent as any)._elementList);\r\n}\r\n\r\nexport function getElementList(nodeListElement: HTMLElement): ElementListMapper {\r\n    return (parent as any)._elementList;\r\n}\r\n\r\nexport function targetAttr(eventAttrName: string, functor: s.Stream | Functor1P) {\r\n    return function (event) {\r\n        return functor(event.target[eventAttrName]);\r\n    }\r\n}","import {remove} from './utils';\r\nexport type Changes = Array<Array<any>>;\r\nexport type ArrayListener = (op: string, args: any[], opReturnValue: any) => void;\r\n\r\nexport class ObservableArray<T> {\r\n    array: T[];\r\n    listeners: ArrayListener[];\r\n    changes: Changes;\r\n    constructor(array?: T[]) {\r\n        this.array = array || [];\r\n        this.listeners = [];\r\n        this.changes = null;\r\n    }\r\n\r\n    get length () {\r\n        return this.array.length;\r\n    }\r\n\r\n    push(...args) {\r\n        const retValue = this.array.push.apply(this.array, args);\r\n        this.logChange('push', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    pop(...args) {\r\n        const retValue = this.array.pop.apply(this.array, args);\r\n        this.logChange('pop', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    reverse(...args) {\r\n        const retValue = this.array.reverse.apply(this.array, args);\r\n        this.logChange('reverse', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    shift(...args) {\r\n        const retValue = this.array.shift.apply(this.array, args);\r\n        this.logChange('shift', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    splice(...args) {\r\n        const retValue = this.array.splice.apply(this.array, args);\r\n        this.logChange('splice', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    sort(...args) {\r\n        const retValue = this.array.sort.apply(this.array, args);\r\n        this.logChange('sort', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    unshift(...args) {\r\n        const retValue = this.array.unshift.apply(this.array, args);\r\n        this.logChange('unshift', retValue, args);\r\n        return retValue;\r\n    }\r\n\r\n    remove(value: T) {\r\n        const index = this.array.indexOf(value);\r\n        this.splice(index, 1);\r\n    }\r\n\r\n    applyChanges(changeFunctor: () => any) {\r\n        this.changes = [];\r\n        let result;\r\n        try {\r\n            result = changeFunctor();\r\n        } catch (e) {\r\n            this.changes = null;\r\n            throw e;\r\n        }\r\n        if (this.changes) {\r\n            console.log('emit changes: ', this.changes.length);\r\n            this.emit('changes', this.changes);\r\n        }\r\n        this.changes = null;\r\n        return result;\r\n    }\r\n\r\n    addListener(callback: ArrayListener) {\r\n        this.listeners.push(callback);\r\n        return () => this.removeListener(callback);\r\n    }\r\n\r\n    removeListener(callback: ArrayListener) {\r\n        return remove(this.listeners, callback);\r\n    }\r\n\r\n    logChange(method, returnValue, args) {\r\n        if (this.changes === null) {\r\n            this.emit(method, args, returnValue);\r\n        } else {\r\n            this.changes.push([method, args, returnValue]);\r\n        }\r\n    }\r\n\r\n    emit(op: string, args: any[], opReturnValue?: any) {\r\n        for (let i = 0; i < this.listeners.length; ++i) {\r\n            this.listeners[i](op, args, opReturnValue);\r\n        }\r\n    }\r\n}\r\n\r\nexport type FilterPredicate<T> = (value: T) => any;\r\nexport class Filter<T> {\r\n    src: ObservableArray<T>;\r\n    filtered: ObservableArray<T>;\r\n    predicate: FilterPredicate<T>;\r\n    constructor(src: ObservableArray<T>, predicate: FilterPredicate<T>) {\r\n        this.src = src;\r\n        this.filtered = new ObservableArray();\r\n        this.predicate = predicate;\r\n\r\n        const srcFiltered = this.src.array.filter(this.predicate);\r\n        this.filtered.push(...srcFiltered);\r\n\r\n        this.src.addListener(this.srcChanged.bind(this));\r\n    }\r\n\r\n    applyFilter(predicate: FilterPredicate<T> = null, reset: boolean = false): Changes {\r\n        if (predicate) {\r\n            this.predicate = predicate;\r\n        }\r\n        const changes = this.filtered.applyChanges(() => {\r\n            if (reset) {\r\n                // Reset filter completely:\r\n                this.filtered.splice(0);\r\n                const filteredValues = this.src.array.filter(this.predicate);\r\n                if (filteredValues.length) {\r\n                    this.filtered.push(...filteredValues);\r\n                }\r\n                return this.filtered.changes;\r\n            } \r\n\r\n            console.time('applyFilter');\r\n            // Apply only differences between 2 filter run:\r\n            let filterIndex = 0;\r\n            for (let srcIndex = 0; srcIndex < this.src.length; ++srcIndex) {\r\n                const srcValue = this.src.array[srcIndex];\r\n                if (this.predicate(srcValue)) {\r\n                    if (filterIndex < this.filtered.length) {\r\n                        if (this.filtered.array[filterIndex] !== srcValue) {\r\n                            this.filtered.splice(filterIndex, 0, srcValue);\r\n                        }\r\n                    } else {\r\n                        this.filtered.splice(filterIndex, 0, srcValue);\r\n                    }\r\n                    ++filterIndex;\r\n                } else {\r\n                    if (filterIndex < this.filtered.length) {\r\n                        if (this.filtered.array[filterIndex] === srcValue) {\r\n                            this.filtered.splice(filterIndex, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // All the others elements are not needed anymore.\r\n            if (filterIndex < this.filtered.length) {\r\n                this.filtered.splice(filterIndex);\r\n            }\r\n            console.timeEnd('applyFilter');\r\n\r\n            console.log('remaing: ', this.filtered.length);\r\n\r\n            console.time('apply - dom changes');\r\n            return this.filtered.changes;\r\n        });\r\n\r\n        console.timeEnd('apply - dom changes');\r\n        return changes;\r\n    }\r\n\r\n\r\n    private srcChanged(op: string, args: any[], opReturnValue?: any) {\r\n        switch (op) {\r\n            case 'pop':\r\n                if (this.filtered.length && this.filtered.array[this.filtered.length - 1] === opReturnValue) {\r\n                    this.filtered.pop();\r\n                }\r\n                break;\r\n            case 'push': {\r\n                const filterPushedData = args.filter(this.predicate);\r\n                if (filterPushedData.length) {\r\n                    this.filtered.push(...filterPushedData);\r\n                }\r\n                break;\r\n            }\r\n            case 'reverse': {\r\n                if (this.filtered.length) {\r\n                    this.filtered.reverse();\r\n                }\r\n                break;\r\n            };\r\n            case 'splice':\r\n                const elementsToRemove = opReturnValue;\r\n\r\n                const filteredElementsToRemove = elementsToRemove.filter(this.predicate);\r\n                let filteredElementsAdded;\r\n                if (args.length > 2) {\r\n                    const elementsAdded = args.slice(2);\r\n                    filteredElementsAdded = elementsAdded.filter(this.predicate);\r\n                }\r\n\r\n                const srcSpliceStart = args[0] < 0 ? \r\n                    args[0] + this.src.length + elementsToRemove.length - (args.length > 2 ? args.length - 2 : 0) : \r\n                    args[0];\r\n                // Find the insertion point from the start in case not all elements are unique.\r\n                let filteredSpliceStart = 0;\r\n                for (let i = 0; i < srcSpliceStart; ++i) {\r\n                    if (this.predicate(this.src.array[i])) {\r\n                        ++filteredSpliceStart;\r\n                    }\r\n                }\r\n\r\n                if (filteredElementsToRemove && filteredElementsToRemove.length) {\r\n                    if (filteredElementsAdded && filteredElementsAdded.length) {\r\n                        this.filtered.splice(filteredSpliceStart, filteredElementsToRemove.length, ...filteredElementsAdded);\r\n                    } else {\r\n                        this.filtered.splice(filteredSpliceStart, filteredElementsToRemove.length);\r\n                    }\r\n                } else if (filteredElementsAdded && filteredElementsAdded.length) {\r\n                    this.filtered.splice(filteredSpliceStart, 0, ...filteredElementsAdded);\r\n                }\r\n                break;\r\n            case 'shift':\r\n                if (this.filtered.length && this.filtered.array[0] === opReturnValue) {\r\n                    this.filtered.shift();\r\n                }\r\n                break;\r\n            case 'sort': {\r\n                if (this.filtered.length) {\r\n                    this.filtered.sort();\r\n                }\r\n                break;\r\n            }\r\n            case 'unshift': {\r\n                const filterUnshiftedData = args.filter(this.predicate);\r\n                if (filterUnshiftedData.length) {\r\n                    this.filtered.unshift(...filterUnshiftedData);\r\n                }\r\n                break;\r\n            }\r\n            case 'changes': {\r\n                const changes = args;\r\n                for (let i = 0; i < changes.length; ++i) {\r\n                    this.srcChanged.apply(this, changes[i]);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}","import * as sp from '../../spui/index';\r\nimport * as utils from '../../spui/utils';\r\nconst h = sp.h;\r\n\r\ninterface Model {\r\n    pos: string,\r\n    class: sp.Stream\r\n}\r\nconst mosaicModels = new sp.ObservableArray<Model>();\r\n\r\nfunction createMosaic() {\r\n    return h('div', { id: 'root' }, sp.elementList('div', { class: 'container' }, mosaicModels, (element, model) => {\r\n        return h('div', { class: model.class, style: { backgroundPosition: model.pos } })\r\n    }));\r\n}\r\n\r\nfunction initModels() {\r\n    for (let i = 0; i < 100; i++) {\r\n        mosaicModels.push({\r\n            pos: (i % 10 * 11) + '% ' + (Math.floor(i / 10) * 11) + '%',\r\n            class: sp.valueStream('slice')\r\n        });\r\n    }\r\n}\r\n\r\nfunction fadeOut() {\r\n    mosaicModels.array.forEach(model => model.class('slice exit'));\r\n    setTimeout(fadeIn, 1000);\r\n}\r\n\r\nfunction fadeIn() {\r\n    mosaicModels.splice(0);\r\n    initModels();\r\n    setTimeout(fadeOut, 2000);\r\n}\r\n\r\nconst mosaic = createMosaic();\r\ndocument.body.appendChild(mosaic);\r\nfadeIn();\r\n\r\n"],"names":["s.compute","s.addTransform","h","sp.h","sp.ObservableArray","sp.elementList","sp.valueStream"],"mappings":"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"}